## DP(Dynamic Programming)

### DP는 무엇이고 언제 사용할까

재귀적 알고리즘은 때론 매우 비효율적이다. <br/>
예를 들어 피보나치 수 문제의 경우, n의 피보나치 수는 n-1의 피보나치 수와 n-2의 피보나치 수를 포함하고 있다. 이렇듯 큰 문제의 답에 작은 문제의 답이 포함되어 있으면 **최적부분 구조**를 가졌다고 한다. 최적 부분 구조를 가진 경우 재귀함수로 해결하는 경우가 있는데, 이 예에서는 매우 비효율적일 수 있다.


~~~
int fibo(int n){
    if(n==1 || n==2)
        return 1;
    else
        return (fibo(n-1)+fibo(n-2));
}
~~~
위의 코드처럼 문제를 해결할 경우 중복호출이 문제가 된다. fibo(6)을 구하는 과정에서 fibo(4)는 2번, fibo(3)은 3번, fibo(2)는 5번 호출된다. n이 커질 수록 중복 호출 횟수는 더욱 커질 것이다.<br>
좀 더 효율적으로 바꾸려면, 실행한 fibo()의 값을 저장해두었다가 나중에 필요할 때 사용하면 된다. 이렇게 부분적인 결과를 저장해나가면서 해를 구하는 것이 DP의 핵심이다.<br>

>정리하면<br/>
1 최적 부분 구조를 가지고<br/>
2 재귀적으로 구현 시 중복 호출이 심한<br/>문제의 경우 적절한 방법으로 비효율을 제거하는 방법이 DP이다.


아래의 코드는 DP를 이용한 하나의 방식이다.
~~~
int fibo(int n){
  //배열 f에 작은 것부터 저장해나감
  f[1] = f[2] = 1;

  for(i=3; i<=n;i++)
    f[i] = f[i-1]+f[i-2];

  return f[n];
}
~~~
<hr/>

### DP 예제
##### 행렬 경로 문제

##### 행렬 곱셈 순서 문제
##### LCS(최장 공통 부분 순서, Longest Common Sequence)
