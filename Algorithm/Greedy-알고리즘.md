# Greedy Algorithm
: 눈앞의 이익만 우선 추구하는 알고리즘.<br/>

최적화 문제 풀 때 사용함. <br/>
DP보다 호율적이지만 반드시 최적해 구한다는 보장 없음.

### Greedy 알고리즘으로 최적해가 보장되지 않는 예
Greedy 대부분의 경우 최적해를 보장하지 못함.<br/>

예시
1. Binary tree 최적합 경로 찾기
>모든 노드(가중치)를 다 보기 전에는 최적해 보장할 수 없음. (백트래킹 탐색해야 함)

2. Knapsack Problem (배낭 문제)<br/>
: 물건(i)들의 부피(W(i))의 합이 M을 넘지 않으면서 가치(P(i))가 최대가 되도록 함
> 배낭의 용량을 초과하지 않은 한 단위 부피당 가치가 가장 큰 순서로 배낭에 추가한다.<br/><br/>
>-*NP-Hard* 문제(0/1 Knapsack Problem)<br/>
>-물건을 자를 수 있는 경우에는 최적해 보장함(Fractional Knapsack Problem)

3. 동전 거스름돈<br/>: 가장 적은 개수의 동전을 사용해 거스름돈 거슬러주기
> - 동전의 액면이 바로 아래 액면의 *배수* 이면  그리디한 방식으로 *최적해 보장*.(ex.500원, 100원, 50원, 10원)<br/>
>- 동전의 액면이 바로 아래 액면의 *배수가 되지 않는* 경우 *최적해 보장되지 않음*(ex. 500원, 300원, 70원, 40원) => DP로 최적해 구할 수 있음.


### Greedy 알고리즘로 최적해가 보장되는 예
1. 최소 신장 트리(Minimum Spanning Tree)<br/>: 그래프 내의 모든 정점을 최소 비용으로 연결하는 트리<br/>
최소 신장 트리를 위한 알고리즘에는 `프림 알고리즘`, `크루스칼 알고리즘`

2. 회의실 배정 문제<br/>:
1개의 회의실에 대해 받은 n개의 회의 신청(시작시간과 종료시간 명시). 겹치지 않으면서 가장 많은 수의 회의를 할 수 있도록 함.
> 1 종료 시간이 빠른 순서로 정렬함. <br/>
ex. 정렬 결과 (시작시간, 종료시간)<br/>
(3,5), (2,6), (5,7), (8,13), (9,12), (11,18), (14,15)<br/>
2 순서대로 회의를 포함시킬지 확인함.<br/>
결과: (3,5), (5,7), (8,13), (14,15)

3. Huffman Coding<br/>:
문서에서 각 원소들의 출현 빈도가 주어질 때, 문서를 효율적으로 압축하는 코드를 만드는 알고리즘
